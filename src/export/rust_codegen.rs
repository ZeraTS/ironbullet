use crate::pipeline::block::*;
use crate::pipeline::Pipeline;
use std::collections::HashSet;

/// Generate a standalone Rust program from a pipeline
pub fn generate_rust_code(pipeline: &Pipeline) -> String {
    let mut code = String::new();

    // Scan blocks to determine which imports are needed
    let mut needed = ImportFlags::default();
    scan_blocks_for_imports(&pipeline.blocks, &mut needed);

    code.push_str("// Generated by reqflow\n");
    code.push_str("use wreq::Client;\n");
    code.push_str("use wreq_util::Emulation;\n");
    if needed.regex {
        code.push_str("use regex::Regex;\n");
    }
    if needed.serde_json {
        code.push_str("use serde_json::Value;\n");
    }
    if needed.scraper {
        code.push_str("use scraper::{Html, Selector};\n");
    }
    if needed.xpath {
        code.push_str("use sxd_document;\nuse sxd_xpath;\n");
    }
    if needed.crypto {
        code.push_str("use sha2::Digest;\n");
    }
    if needed.chrono {
        code.push_str("use chrono::prelude::*;\n");
    }
    if needed.browser {
        code.push_str("use chromiumoxide::browser::{Browser, BrowserConfig};\n");
        code.push_str("use futures::StreamExt;\n");
    }
    if needed.rand {
        code.push_str("use rand::Rng;\n");
    }
    if needed.net {
        code.push_str("use tokio::io::{AsyncReadExt, AsyncWriteExt, AsyncBufReadExt};\n");
    }
    if needed.urlencoding {
        code.push_str("// url encoding: use urlencoding::{encode, decode};\n");
    }
    if needed.base64 {
        code.push_str("use base64::Engine as _;\n");
    }
    code.push_str("\n");
    code.push_str("#[tokio::main]\n");
    code.push_str("async fn main() -> Result<(), Box<dyn std::error::Error>> {\n");

    // Client setup
    let browser = &pipeline.browser_settings.browser;
    let emulation = match browser.as_str() {
        "chrome" => "Chrome131",
        "firefox" => "Firefox133",
        "safari" => "Safari18",
        "edge" => "Edge131",
        _ => "Chrome131",
    };
    code.push_str(&format!("    let client = Client::builder()\n"));
    code.push_str(&format!("        .emulation(Emulation::{})\n", emulation));
    code.push_str("        .build()?;\n\n");

    // Track defined variables
    let mut vars = VarTracker::new();

    // Generate blocks
    for (i, block) in pipeline.blocks.iter().enumerate() {
        if block.disabled {
            continue;
        }
        code.push_str(&format!("    // Block {}: {}\n", i + 1, block.label));
        code.push_str(&generate_block_code(block, 1, &mut vars));
        code.push_str("\n");
    }

    code.push_str("    Ok(())\n");
    code.push_str("}\n");

    code
}

// ── Import scanning ──

#[derive(Default)]
struct ImportFlags {
    regex: bool,
    serde_json: bool,
    scraper: bool,
    xpath: bool,
    crypto: bool,
    chrono: bool,
    browser: bool,
    urlencoding: bool,
    base64: bool,
    rand: bool,
    net: bool,
}

fn scan_blocks_for_imports(blocks: &[Block], flags: &mut ImportFlags) {
    for block in blocks {
        match &block.settings {
            BlockSettings::ParseRegex(_) => flags.regex = true,
            BlockSettings::ParseJSON(_) => flags.serde_json = true,
            BlockSettings::ParseCSS(_) => flags.scraper = true,
            BlockSettings::ParseXPath(_) => flags.xpath = true,
            BlockSettings::CryptoFunction(_) => flags.crypto = true,
            BlockSettings::DateFunction(_) => flags.chrono = true,
            BlockSettings::BrowserOpen(_) | BlockSettings::NavigateTo(_) |
            BlockSettings::ClickElement(_) | BlockSettings::TypeText(_) |
            BlockSettings::WaitForElement(_) | BlockSettings::GetElementText(_) |
            BlockSettings::Screenshot(_) | BlockSettings::ExecuteJs(_) => flags.browser = true,
            BlockSettings::StringFunction(s) => {
                match s.function_type {
                    StringFnType::URLEncode | StringFnType::URLDecode => flags.urlencoding = true,
                    StringFnType::Base64Encode | StringFnType::Base64Decode => flags.base64 = true,
                    _ => {}
                }
            }
            BlockSettings::ConversionFunction(s) => {
                if s.from_type == "base64" || s.to_type == "base64" {
                    flags.base64 = true;
                }
            }
            BlockSettings::RandomData(_) => { flags.rand = true; }
            BlockSettings::TcpRequest(_) | BlockSettings::UdpRequest(_) |
            BlockSettings::FtpRequest(_) | BlockSettings::SshRequest(_) |
            BlockSettings::ImapRequest(_) | BlockSettings::SmtpRequest(_) |
            BlockSettings::PopRequest(_) => { flags.net = true; }
            BlockSettings::CaptchaSolver(_) | BlockSettings::CloudflareBypass(_) => { flags.serde_json = true; }
            BlockSettings::LaravelCsrf(_) => { flags.scraper = true; }
            BlockSettings::IfElse(s) => {
                scan_blocks_for_imports(&s.true_blocks, flags);
                scan_blocks_for_imports(&s.false_blocks, flags);
            }
            BlockSettings::Loop(s) => {
                scan_blocks_for_imports(&s.blocks, flags);
            }
            BlockSettings::Group(s) => {
                scan_blocks_for_imports(&s.blocks, flags);
            }
            _ => {}
        }
    }
}

// ── Variable tracking ──

struct VarTracker {
    defined: HashSet<String>,
}

impl VarTracker {
    fn new() -> Self {
        Self { defined: HashSet::new() }
    }

    fn define(&mut self, name: &str) {
        self.defined.insert(var_name(name));
    }

    fn is_defined(&self, name: &str) -> bool {
        self.defined.contains(&var_name(name))
    }

    /// Returns "let " if variable is new, "" if reassigning
    fn let_or_assign(&mut self, name: &str) -> &'static str {
        let vn = var_name(name);
        if self.defined.contains(&vn) {
            ""
        } else {
            self.defined.insert(vn);
            "let "
        }
    }
}

fn generate_block_code(block: &Block, indent: usize, vars: &mut VarTracker) -> String {
    let pad = "    ".repeat(indent);
    let mut code = String::new();

    match &block.settings {
        BlockSettings::HttpRequest(s) => {
            let method = s.method.to_lowercase();
            code.push_str(&format!("{}let resp = client.{}(\"{}\")\n", pad, method, s.url));
            for (k, v) in &s.headers {
                code.push_str(&format!("{}    .header(\"{}\", \"{}\")\n", pad, escape_str(k), escape_str(v)));
            }
            if !s.custom_cookies.is_empty() {
                code.push_str(&format!("{}    .header(\"Cookie\", \"{}\")\n", pad, escape_str(&s.custom_cookies.replace('\n', "; "))));
            }
            if !s.body.is_empty() && method != "get" {
                code.push_str(&format!("{}    .body(r#\"{}\"#)\n", pad, s.body));
            }
            code.push_str(&format!("{}    .send()\n", pad));
            code.push_str(&format!("{}    .await?;\n\n", pad));
            let var_prefix = if s.response_var.is_empty() { "SOURCE" } else { &s.response_var };
            code.push_str(&format!("{}let status_code = resp.status().as_u16();\n", pad));
            code.push_str(&format!("{}let {} = resp.text().await?;\n", pad, var_name(var_prefix)));
            vars.define(var_prefix);
            vars.define("status_code");
        }
        BlockSettings::ParseLR(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            let letkw = vars.let_or_assign(&s.output_var);
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, var_name(&s.output_var)));
            code.push_str(&format!("{}    let left = \"{}\";\n", pad, escape_str(&s.left)));
            code.push_str(&format!("{}    let right = \"{}\";\n", pad, escape_str(&s.right)));
            code.push_str(&format!("{}    if let Some(start) = {}.find(left) {{\n", pad, input));
            code.push_str(&format!("{}        let after = start + left.len();\n", pad));
            code.push_str(&format!("{}        if let Some(end) = {}[after..].find(right) {{\n", pad, input));
            code.push_str(&format!("{}            {}[after..after + end].to_string()\n", pad, input));
            code.push_str(&format!("{}        }} else {{ String::new() }}\n", pad));
            code.push_str(&format!("{}    }} else {{ String::new() }}\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::ParseRegex(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            code.push_str(&format!("{}let re = Regex::new(r\"{}\")?;\n", pad, s.pattern));
            let letkw = vars.let_or_assign(&s.output_var);
            code.push_str(&format!("{}{}{}= re.captures(&{})\n", pad, letkw, var_name(&s.output_var), input));
            code.push_str(&format!("{}    .and_then(|c| c.get(1))\n", pad));
            code.push_str(&format!("{}    .map(|m| m.as_str().to_string())\n", pad));
            code.push_str(&format!("{}    .unwrap_or_default();\n", pad));
        }
        BlockSettings::ParseJSON(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            let pointer = if s.json_path.starts_with('/') {
                s.json_path.clone()
            } else {
                format!("/{}", s.json_path.replace('.', "/"))
            };
            code.push_str(&format!("{}let json: Value = serde_json::from_str(&{})?;\n", pad, input));
            let letkw = vars.let_or_assign(&s.output_var);
            code.push_str(&format!("{}{}{}= json.pointer(\"{}\")\n", pad, letkw, var_name(&s.output_var), pointer));
            code.push_str(&format!("{}    .map(|v| match v {{ Value::String(s) => s.clone(), other => other.to_string() }})\n", pad));
            code.push_str(&format!("{}    .unwrap_or_default();\n", pad));
        }
        BlockSettings::ParseCSS(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            code.push_str(&format!("{}let document = Html::parse_document(&{});\n", pad, input));
            code.push_str(&format!("{}let css_sel = Selector::parse(\"{}\").unwrap();\n", pad, escape_str(&s.selector)));
            let letkw = vars.let_or_assign(&s.output_var);
            if s.attribute == "innerText" || s.attribute.is_empty() {
                code.push_str(&format!("{}{}{}= document.select(&css_sel)\n", pad, letkw, var_name(&s.output_var)));
                code.push_str(&format!("{}    .nth({} as usize)\n", pad, s.index));
                code.push_str(&format!("{}    .map(|el| el.text().collect::<String>())\n", pad));
                code.push_str(&format!("{}    .unwrap_or_default();\n", pad));
            } else {
                code.push_str(&format!("{}{}{}= document.select(&css_sel)\n", pad, letkw, var_name(&s.output_var)));
                code.push_str(&format!("{}    .nth({} as usize)\n", pad, s.index));
                code.push_str(&format!("{}    .and_then(|el| el.value().attr(\"{}\"))\n", pad, escape_str(&s.attribute)));
                code.push_str(&format!("{}    .unwrap_or_default()\n", pad));
                code.push_str(&format!("{}    .to_string();\n", pad));
            }
        }
        BlockSettings::ParseXPath(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            let letkw = vars.let_or_assign(&s.output_var);
            code.push_str(&format!("{}let xpath_pkg = sxd_document::parser::parse(&{}).unwrap();\n", pad, input));
            code.push_str(&format!("{}let xpath_doc = xpath_pkg.as_document();\n", pad));
            code.push_str(&format!("{}let xpath_factory = sxd_xpath::Factory::new();\n", pad));
            code.push_str(&format!("{}let xpath_expr = xpath_factory.build(\"{}\").unwrap().unwrap();\n", pad, escape_str(&s.xpath)));
            code.push_str(&format!("{}let xpath_ctx = sxd_xpath::Context::new();\n", pad));
            code.push_str(&format!("{}let xpath_val = xpath_expr.evaluate(&xpath_ctx, xpath_doc.root()).unwrap();\n", pad));
            code.push_str(&format!("{}{}{}= match xpath_val {{\n", pad, letkw, var_name(&s.output_var)));
            code.push_str(&format!("{}    sxd_xpath::Value::String(s) => s,\n", pad));
            code.push_str(&format!("{}    sxd_xpath::Value::Nodeset(nodes) => {{\n", pad));
            code.push_str(&format!("{}        nodes.document_order().first().map(|n| n.string_value()).unwrap_or_default()\n", pad));
            code.push_str(&format!("{}    }}\n", pad));
            code.push_str(&format!("{}    sxd_xpath::Value::Number(n) => n.to_string(),\n", pad));
            code.push_str(&format!("{}    sxd_xpath::Value::Boolean(b) => b.to_string(),\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::ParseCookie(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            let letkw = vars.let_or_assign(&s.output_var);
            code.push_str(&format!("{}{}{}= {}.split(';')\n", pad, letkw, var_name(&s.output_var), input));
            code.push_str(&format!("{}    .filter_map(|pair| {{\n", pad));
            code.push_str(&format!("{}        let pair = pair.trim();\n", pad));
            code.push_str(&format!("{}        let eq = pair.find('=')?;\n", pad));
            code.push_str(&format!("{}        Some((&pair[..eq], &pair[eq + 1..]))\n", pad));
            code.push_str(&format!("{}    }})\n", pad));
            code.push_str(&format!("{}    .find(|(name, _)| *name == \"{}\")\n", pad, escape_str(&s.cookie_name)));
            code.push_str(&format!("{}    .map(|(_, v)| v.to_string())\n", pad));
            code.push_str(&format!("{}    .unwrap_or_default();\n", pad));
        }
        BlockSettings::KeyCheck(s) => {
            for (i, keychain) in s.keychains.iter().enumerate() {
                let prefix = if i == 0 { "if" } else { "} else if" };
                let conditions: Vec<String> = keychain.conditions.iter()
                    .map(|c| generate_condition_code(c))
                    .collect();
                let cond_str = conditions.join(" && ");
                let status = format!("{:?}", keychain.result).to_uppercase();
                code.push_str(&format!("{}{} {} {{\n", pad, prefix, cond_str));
                code.push_str(&format!("{}    println!(\"{}\");\n", pad, status));
            }
            if !s.keychains.is_empty() {
                code.push_str(&format!("{}}}\n", pad));
            }
        }
        BlockSettings::StringFunction(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            match s.function_type {
                StringFnType::Replace => {
                    code.push_str(&format!("{}{}{}= {}.replace(\"{}\", \"{}\");\n",
                        pad, letkw, vn, input, escape_str(&s.param1), escape_str(&s.param2)));
                }
                StringFnType::ToLower => {
                    code.push_str(&format!("{}{}{}= {}.to_lowercase();\n", pad, letkw, vn, input));
                }
                StringFnType::ToUpper => {
                    code.push_str(&format!("{}{}{}= {}.to_uppercase();\n", pad, letkw, vn, input));
                }
                StringFnType::Trim => {
                    code.push_str(&format!("{}{}{}= {}.trim().to_string();\n", pad, letkw, vn, input));
                }
                StringFnType::Substring => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let start: usize = \"{}\".parse().unwrap_or(0);\n", pad, escape_str(&s.param1)));
                    code.push_str(&format!("{}    let len: usize = \"{}\".parse().unwrap_or({}.len());\n", pad, escape_str(&s.param2), input));
                    code.push_str(&format!("{}    {}.chars().skip(start).take(len).collect::<String>()\n", pad, input));
                    code.push_str(&format!("{}}};\n", pad));
                }
                StringFnType::URLEncode => {
                    code.push_str(&format!("{}{}{}= urlencoding::encode(&{}).to_string();\n", pad, letkw, vn, input));
                }
                StringFnType::URLDecode => {
                    code.push_str(&format!("{}{}{}= urlencoding::decode(&{}).unwrap_or_default().to_string();\n", pad, letkw, vn, input));
                }
                StringFnType::Base64Encode => {
                    code.push_str(&format!("{}{}{}= base64::engine::general_purpose::STANDARD.encode({}.as_bytes());\n", pad, letkw, vn, input));
                }
                StringFnType::Base64Decode => {
                    code.push_str(&format!("{}{}{}= String::from_utf8(base64::engine::general_purpose::STANDARD.decode(&{}).unwrap_or_default()).unwrap_or_default();\n", pad, letkw, vn, input));
                }
                StringFnType::HTMLEntityEncode => {
                    code.push_str(&format!("{}{}{}= {}.replace('&', \"&amp;\").replace('<', \"&lt;\").replace('>', \"&gt;\").replace('\"', \"&quot;\");\n", pad, letkw, vn, input));
                }
                StringFnType::HTMLEntityDecode => {
                    code.push_str(&format!("{}{}{}= {}.replace(\"&amp;\", \"&\").replace(\"&lt;\", \"<\").replace(\"&gt;\", \">\").replace(\"&quot;\", \"\\\"\");\n", pad, letkw, vn, input));
                }
                StringFnType::Split => {
                    code.push_str(&format!("{}{}{}= {}.split(\"{}\").collect::<Vec<_>>().join(\"\\n\");\n", pad, letkw, vn, input, escape_str(&s.param1)));
                }
                StringFnType::Reverse => {
                    code.push_str(&format!("{}{}{}= {}.chars().rev().collect::<String>();\n", pad, letkw, vn, input));
                }
                StringFnType::Length => {
                    code.push_str(&format!("{}{}{}= {}.len().to_string();\n", pad, letkw, vn, input));
                }
                StringFnType::RandomString => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let len: usize = \"{}\".parse().unwrap_or(16);\n", pad, escape_str(&s.param1)));
                    code.push_str(&format!("{}    use rand::Rng;\n", pad));
                    code.push_str(&format!("{}    let mut rng = rand::thread_rng();\n", pad));
                    code.push_str(&format!("{}    (0..len).map(|_| rng.sample(rand::distributions::Alphanumeric) as char).collect::<String>()\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
            }
        }
        BlockSettings::ListFunction(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            match s.function_type {
                ListFnType::Join => {
                    let sep = if s.param1.is_empty() { ", " } else { &s.param1 };
                    code.push_str(&format!("{}{}{}= {}.lines().collect::<Vec<_>>().join(\"{}\");\n", pad, letkw, vn, input, escape_str(sep)));
                }
                ListFnType::Sort => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let mut items: Vec<&str> = {}.lines().collect();\n", pad, input));
                    code.push_str(&format!("{}    items.sort();\n", pad));
                    code.push_str(&format!("{}    items.join(\"\\n\")\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                ListFnType::Shuffle => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    use rand::seq::SliceRandom;\n", pad));
                    code.push_str(&format!("{}    let mut items: Vec<&str> = {}.lines().collect();\n", pad, input));
                    code.push_str(&format!("{}    items.shuffle(&mut rand::thread_rng());\n", pad));
                    code.push_str(&format!("{}    items.join(\"\\n\")\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                ListFnType::Add => {
                    code.push_str(&format!("{}{}{}= format!(\"{{}}\\n{}\", {});\n", pad, letkw, vn, escape_str(&s.param1), input));
                }
                ListFnType::Remove => {
                    code.push_str(&format!("{}{}{}= {}.lines().filter(|l| *l != \"{}\").collect::<Vec<_>>().join(\"\\n\");\n", pad, letkw, vn, input, escape_str(&s.param1)));
                }
                ListFnType::Deduplicate => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let mut seen = std::collections::HashSet::new();\n", pad));
                    code.push_str(&format!("{}    {}.lines().filter(|l| seen.insert(l.to_string())).collect::<Vec<_>>().join(\"\\n\")\n", pad, input));
                    code.push_str(&format!("{}}};\n", pad));
                }
                ListFnType::RandomItem => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    use rand::seq::SliceRandom;\n", pad));
                    code.push_str(&format!("{}    let items: Vec<&str> = {}.lines().collect();\n", pad, input));
                    code.push_str(&format!("{}    items.choose(&mut rand::thread_rng()).unwrap_or(&\"\").to_string()\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                ListFnType::Length => {
                    code.push_str(&format!("{}{}{}= {}.lines().count().to_string();\n", pad, letkw, vn, input));
                }
            }
        }
        BlockSettings::CryptoFunction(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            match s.function_type {
                CryptoFnType::MD5 => {
                    code.push_str(&format!("{}{}{}= format!(\"{{:x}}\", md5::compute({}.as_bytes()));\n", pad, letkw, vn, input));
                }
                CryptoFnType::SHA1 => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let mut hasher = sha1::Sha1::new();\n", pad));
                    code.push_str(&format!("{}    hasher.update({}.as_bytes());\n", pad, input));
                    code.push_str(&format!("{}    format!(\"{{:x}}\", hasher.finalize())\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                CryptoFnType::SHA256 => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let mut hasher = sha2::Sha256::new();\n", pad));
                    code.push_str(&format!("{}    hasher.update({}.as_bytes());\n", pad, input));
                    code.push_str(&format!("{}    format!(\"{{:x}}\", hasher.finalize())\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                CryptoFnType::SHA384 => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let mut hasher = sha2::Sha384::new();\n", pad));
                    code.push_str(&format!("{}    hasher.update({}.as_bytes());\n", pad, input));
                    code.push_str(&format!("{}    format!(\"{{:x}}\", hasher.finalize())\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                CryptoFnType::SHA512 => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let mut hasher = sha2::Sha512::new();\n", pad));
                    code.push_str(&format!("{}    hasher.update({}.as_bytes());\n", pad, input));
                    code.push_str(&format!("{}    format!(\"{{:x}}\", hasher.finalize())\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                CryptoFnType::CRC32 => {
                    code.push_str(&format!("{}{}{}= format!(\"{{}}\", crc32fast::hash({}.as_bytes()));\n", pad, letkw, vn, input));
                }
                CryptoFnType::HMACSHA256 => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    use hmac::{{Hmac, Mac}};\n", pad));
                    code.push_str(&format!("{}    type HmacSha256 = Hmac<sha2::Sha256>;\n", pad));
                    code.push_str(&format!("{}    let mut mac = HmacSha256::new_from_slice(\"{}\".as_bytes()).unwrap();\n", pad, escape_str(&s.key)));
                    code.push_str(&format!("{}    mac.update({}.as_bytes());\n", pad, input));
                    code.push_str(&format!("{}    format!(\"{{:x}}\", mac.finalize().into_bytes())\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                CryptoFnType::HMACSHA512 => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    use hmac::{{Hmac, Mac}};\n", pad));
                    code.push_str(&format!("{}    type HmacSha512 = Hmac<sha2::Sha512>;\n", pad));
                    code.push_str(&format!("{}    let mut mac = HmacSha512::new_from_slice(\"{}\".as_bytes()).unwrap();\n", pad, escape_str(&s.key)));
                    code.push_str(&format!("{}    mac.update({}.as_bytes());\n", pad, input));
                    code.push_str(&format!("{}    format!(\"{{:x}}\", mac.finalize().into_bytes())\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                CryptoFnType::HMACMD5 => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    use hmac::{{Hmac, Mac}};\n", pad));
                    code.push_str(&format!("{}    type HmacMd5 = Hmac<md5::Md5>;\n", pad));
                    code.push_str(&format!("{}    let mut mac = HmacMd5::new_from_slice(\"{}\".as_bytes()).unwrap();\n", pad, escape_str(&s.key)));
                    code.push_str(&format!("{}    mac.update({}.as_bytes());\n", pad, input));
                    code.push_str(&format!("{}    format!(\"{{:x}}\", mac.finalize().into_bytes())\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                CryptoFnType::Base64Encode => {
                    code.push_str(&format!("{}{}{}= base64::engine::general_purpose::STANDARD.encode({}.as_bytes());\n", pad, letkw, vn, input));
                }
                CryptoFnType::Base64Decode => {
                    code.push_str(&format!("{}{}{}= String::from_utf8(base64::engine::general_purpose::STANDARD.decode(&{}).unwrap_or_default()).unwrap_or_default();\n", pad, letkw, vn, input));
                }
                CryptoFnType::BCryptHash => {
                    code.push_str(&format!("{}{}{}= bcrypt::hash(&{}, bcrypt::DEFAULT_COST).unwrap_or_default();\n", pad, letkw, vn, input));
                }
                CryptoFnType::BCryptVerify => {
                    code.push_str(&format!("{}{}{}= bcrypt::verify(&{}, \"{}\").unwrap_or(false).to_string();\n", pad, letkw, vn, input, escape_str(&s.key)));
                }
                CryptoFnType::AESEncrypt | CryptoFnType::AESDecrypt => {
                    code.push_str(&format!("{}// TODO: AES encrypt/decrypt requires additional setup (IV, mode)\n", pad));
                    code.push_str(&format!("{}{}{}= String::new();\n", pad, letkw, vn));
                }
            }
        }
        BlockSettings::ConversionFunction(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            let from = s.from_type.as_str();
            let to = s.to_type.as_str();
            match (from, to) {
                ("string", "int") => {
                    code.push_str(&format!("{}{}{}= {}.parse::<i64>().unwrap_or(0).to_string();\n", pad, letkw, vn, input));
                }
                ("int", "string") | ("float", "string") => {
                    code.push_str(&format!("{}{}{}= {}.to_string();\n", pad, letkw, vn, input));
                }
                ("string", "float") => {
                    code.push_str(&format!("{}{}{}= {}.parse::<f64>().unwrap_or(0.0).to_string();\n", pad, letkw, vn, input));
                }
                ("hex", "string") => {
                    code.push_str(&format!("{}{}{}= hex::decode(&{}).map(|b| String::from_utf8_lossy(&b).to_string()).unwrap_or_default();\n", pad, letkw, vn, input));
                }
                ("string", "hex") => {
                    code.push_str(&format!("{}{}{}= hex::encode({}.as_bytes());\n", pad, letkw, vn, input));
                }
                ("base64", "string") => {
                    code.push_str(&format!("{}{}{}= String::from_utf8(base64::engine::general_purpose::STANDARD.decode(&{}).unwrap_or_default()).unwrap_or_default();\n", pad, letkw, vn, input));
                }
                ("string", "base64") => {
                    code.push_str(&format!("{}{}{}= base64::engine::general_purpose::STANDARD.encode({}.as_bytes());\n", pad, letkw, vn, input));
                }
                _ => {
                    code.push_str(&format!("{}{}{}= {}.to_string(); // {}→{}\n", pad, letkw, vn, input, from, to));
                }
            }
        }
        BlockSettings::DateFunction(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            match s.function_type {
                DateFnType::Now => {
                    code.push_str(&format!("{}{}{}= Local::now().format(\"{}\").to_string();\n", pad, letkw, vn, escape_str(&s.format)));
                }
                DateFnType::UnixTimestamp => {
                    code.push_str(&format!("{}{}{}= Utc::now().timestamp().to_string();\n", pad, letkw, vn));
                }
                DateFnType::UnixToDate => {
                    let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let ts: i64 = {}.parse().unwrap_or(0);\n", pad, input));
                    code.push_str(&format!("{}    DateTime::from_timestamp(ts, 0).map(|dt| dt.format(\"{}\").to_string()).unwrap_or_default()\n", pad, escape_str(&s.format)));
                    code.push_str(&format!("{}}};\n", pad));
                }
                DateFnType::FormatDate => {
                    let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    // Parse input date and reformat\n", pad));
                    code.push_str(&format!("{}    NaiveDateTime::parse_from_str(&{}, \"%Y-%m-%d %H:%M:%S\")\n", pad, input));
                    code.push_str(&format!("{}        .map(|dt| dt.format(\"{}\").to_string())\n", pad, escape_str(&s.format)));
                    code.push_str(&format!("{}        .unwrap_or_default()\n", pad));
                    code.push_str(&format!("{}}};\n", pad));
                }
                DateFnType::ParseDate => {
                    let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
                    code.push_str(&format!("{}{}{}= NaiveDateTime::parse_from_str(&{}, \"{}\").map(|d| d.to_string()).unwrap_or_default();\n",
                        pad, letkw, vn, input, escape_str(&s.format)));
                }
                DateFnType::AddTime | DateFnType::SubtractTime => {
                    let op = if matches!(s.function_type, DateFnType::AddTime) { "+" } else { "-" };
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let now = Local::now();\n", pad));
                    let dur = match s.unit.as_str() {
                        "seconds" => format!("chrono::Duration::seconds({})", s.amount),
                        "minutes" => format!("chrono::Duration::minutes({})", s.amount),
                        "hours" => format!("chrono::Duration::hours({})", s.amount),
                        "days" => format!("chrono::Duration::days({})", s.amount),
                        _ => format!("chrono::Duration::seconds({})", s.amount),
                    };
                    code.push_str(&format!("{}    (now {} {}).format(\"{}\").to_string()\n", pad, op, dur, escape_str(&s.format)));
                    code.push_str(&format!("{}}};\n", pad));
                }
            }
        }
        BlockSettings::CaseSwitch(s) => {
            let input = if vars.is_defined(&s.input_var) { var_name(&s.input_var) } else { "source".into() };
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}{}{}= match {}.as_str() {{\n", pad, letkw, vn, input));
            for case in &s.cases {
                code.push_str(&format!("{}    \"{}\" => \"{}\".to_string(),\n", pad, escape_str(&case.match_value), escape_str(&case.result_value)));
            }
            code.push_str(&format!("{}    _ => \"{}\".to_string(),\n", pad, escape_str(&s.default_value)));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::IfElse(s) => {
            let cond = generate_condition_code(&s.condition);
            code.push_str(&format!("{}if {} {{\n", pad, cond));
            for child in &s.true_blocks {
                if !child.disabled {
                    code.push_str(&generate_block_code(child, indent + 1, vars));
                }
            }
            if !s.false_blocks.is_empty() {
                code.push_str(&format!("{}}} else {{\n", pad));
                for child in &s.false_blocks {
                    if !child.disabled {
                        code.push_str(&generate_block_code(child, indent + 1, vars));
                    }
                }
            }
            code.push_str(&format!("{}}}\n", pad));
        }
        BlockSettings::Loop(s) => {
            match s.loop_type {
                LoopType::ForEach => {
                    let input = if vars.is_defined(&s.list_var) { var_name(&s.list_var) } else { "source".into() };
                    let item = var_name(&s.item_var);
                    code.push_str(&format!("{}for {} in {}.lines() {{\n", pad, item, input));
                    vars.define(&s.item_var);
                    for child in &s.blocks {
                        if !child.disabled {
                            code.push_str(&generate_block_code(child, indent + 1, vars));
                        }
                    }
                    code.push_str(&format!("{}}}\n", pad));
                }
                LoopType::Repeat => {
                    code.push_str(&format!("{}for _i in 0..{} {{\n", pad, s.count));
                    for child in &s.blocks {
                        if !child.disabled {
                            code.push_str(&generate_block_code(child, indent + 1, vars));
                        }
                    }
                    code.push_str(&format!("{}}}\n", pad));
                }
            }
        }
        BlockSettings::Script(s) => {
            code.push_str(&format!("{}// Script block (original code below):\n", pad));
            for line in s.code.lines() {
                code.push_str(&format!("{}// {}\n", pad, line));
            }
            if !s.output_var.is_empty() {
                let letkw = vars.let_or_assign(&s.output_var);
                code.push_str(&format!("{}{}{}= String::new(); // TODO: implement script logic\n", pad, letkw, var_name(&s.output_var)));
            }
        }
        BlockSettings::CookieContainer(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            if s.source_type == "file" {
                code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                code.push_str(&format!("{}    let content = std::fs::read_to_string(\"{}\")?;\n", pad, escape_str(&s.source)));
                code.push_str(&format!("{}    // Parse Netscape cookie format\n", pad));
                code.push_str(&format!("{}    content.lines()\n", pad));
                code.push_str(&format!("{}        .filter(|l| !l.starts_with('#') && !l.is_empty())\n", pad));
                code.push_str(&format!("{}        .filter_map(|l| {{\n", pad));
                code.push_str(&format!("{}            let parts: Vec<&str> = l.split('\\t').collect();\n", pad));
                code.push_str(&format!("{}            if parts.len() >= 7 {{ Some(format!(\"{{}}={{}}\", parts[5], parts[6])) }} else {{ None }}\n", pad));
                code.push_str(&format!("{}        }})\n", pad));
                code.push_str(&format!("{}        .collect::<Vec<_>>().join(\"; \")\n", pad));
                code.push_str(&format!("{}}};\n", pad));
            } else {
                code.push_str(&format!("{}{}{}= \"{}\".to_string();\n", pad, letkw, vn, escape_str(&s.source)));
            }
        }
        BlockSettings::Webhook(s) => {
            let method = s.method.to_lowercase();
            code.push_str(&format!("{}let webhook_resp = client.{}(\"{}\")\n", pad, method, s.url));
            for (k, v) in &s.headers {
                code.push_str(&format!("{}    .header(\"{}\", \"{}\")\n", pad, escape_str(k), escape_str(v)));
            }
            if !s.body_template.is_empty() {
                code.push_str(&format!("{}    .body(r#\"{}\"#)\n", pad, s.body_template));
            }
            code.push_str(&format!("{}    .send()\n", pad));
            code.push_str(&format!("{}    .await?;\n", pad));
        }
        BlockSettings::SetVariable(s) => {
            let letkw = vars.let_or_assign(&s.name);
            code.push_str(&format!("{}{}{}= \"{}\".to_string();\n", pad, letkw, var_name(&s.name), escape_str(&s.value)));
        }
        BlockSettings::Delay(s) => {
            if s.min_ms == s.max_ms {
                code.push_str(&format!("{}tokio::time::sleep(std::time::Duration::from_millis({})).await;\n", pad, s.min_ms));
            } else {
                code.push_str(&format!("{}tokio::time::sleep(std::time::Duration::from_millis(rand::Rng::gen_range(&mut rand::thread_rng(), {}..={}))).await;\n", pad, s.min_ms, s.max_ms));
            }
        }
        BlockSettings::Log(s) => {
            code.push_str(&format!("{}println!(\"{}\");\n", pad, escape_str(&s.message)));
        }
        BlockSettings::ClearCookies => {
            code.push_str(&format!("{}// Clear session cookies (rebuild client or cookie jar)\n", pad));
        }
        // Browser automation
        BlockSettings::BrowserOpen(s) => {
            code.push_str(&format!("{}let (browser, mut handler) = Browser::launch(\n", pad));
            code.push_str(&format!("{}    BrowserConfig::builder()\n", pad));
            if s.headless {
                code.push_str(&format!("{}        .with_head()\n", pad));
            }
            code.push_str(&format!("{}        .build()\n", pad));
            code.push_str(&format!("{}        .map_err(|e| format!(\"Browser config error: {{}}\", e))?\n", pad));
            code.push_str(&format!("{}).await?;\n", pad));
            code.push_str(&format!("{}tokio::spawn(async move {{ while handler.next().await.is_some() {{}} }});\n", pad));
        }
        BlockSettings::NavigateTo(s) => {
            code.push_str(&format!("{}let page = browser.new_page(\"{}\").await?;\n", pad, escape_str(&s.url)));
            code.push_str(&format!("{}page.wait_for_navigation().await?;\n", pad));
            code.push_str(&format!("{}let source = page.content().await?;\n", pad));
            vars.define("source");
        }
        BlockSettings::ClickElement(s) => {
            code.push_str(&format!("{}page.find_element(\"{}\").await?.click().await?;\n", pad, escape_str(&s.selector)));
            if s.wait_for_navigation {
                code.push_str(&format!("{}page.wait_for_navigation().await?;\n", pad));
            }
        }
        BlockSettings::TypeText(s) => {
            if s.clear_first {
                code.push_str(&format!("{}// Clear field first\n", pad));
                code.push_str(&format!("{}page.find_element(\"{}\").await?.click().await?;\n", pad, escape_str(&s.selector)));
                code.push_str(&format!("{}page.execute(chromiumoxide::cdp::browser_protocol::input::DispatchKeyEventParams::builder().r#type(chromiumoxide::cdp::browser_protocol::input::DispatchKeyEventType::KeyDown).key(\"a\").code(\"KeyA\").modifiers(2).build().unwrap()).await?;\n", pad));
            }
            code.push_str(&format!("{}page.find_element(\"{}\").await?.type_str(\"{}\").await?;\n", pad, escape_str(&s.selector), escape_str(&s.text)));
        }
        BlockSettings::WaitForElement(s) => {
            code.push_str(&format!("{}// Wait for element: {} (state: {})\n", pad, s.selector, s.state));
            code.push_str(&format!("{}let start = std::time::Instant::now();\n", pad));
            code.push_str(&format!("{}while start.elapsed().as_millis() < {} {{\n", pad, s.timeout_ms));
            code.push_str(&format!("{}    if page.find_element(\"{}\").await.is_ok() {{ break; }}\n", pad, escape_str(&s.selector)));
            code.push_str(&format!("{}    tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n", pad));
            code.push_str(&format!("{}}}\n", pad));
        }
        BlockSettings::GetElementText(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            if s.attribute.is_empty() {
                code.push_str(&format!("{}{}{}= page.find_element(\"{}\").await?.inner_text().await?.unwrap_or_default();\n",
                    pad, letkw, vn, escape_str(&s.selector)));
            } else {
                code.push_str(&format!("{}{}{}= page.find_element(\"{}\").await?.attribute(\"{}\").await?.unwrap_or_default();\n",
                    pad, letkw, vn, escape_str(&s.selector), escape_str(&s.attribute)));
            }
        }
        BlockSettings::Screenshot(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}let screenshot_bytes = page.screenshot(\n", pad));
            code.push_str(&format!("{}    chromiumoxide::cdp::browser_protocol::page::CaptureScreenshotParams::builder()\n", pad));
            code.push_str(&format!("{}        .build()\n", pad));
            code.push_str(&format!("{}).await?;\n", pad));
            code.push_str(&format!("{}{}{}= base64::engine::general_purpose::STANDARD.encode(&screenshot_bytes);\n", pad, letkw, vn));
        }
        BlockSettings::ExecuteJs(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}{}{}= page.evaluate_expression(r#\"{}\"#).await?.into_value::<String>().unwrap_or_default();\n",
                pad, letkw, vn, s.code));
        }
        BlockSettings::RandomUserAgent(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    use rand::seq::SliceRandom;\n", pad));
            code.push_str(&format!("{}    let agents = vec![\n", pad));
            code.push_str(&format!("{}        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\",\n", pad));
            code.push_str(&format!("{}        \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\",\n", pad));
            code.push_str(&format!("{}        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0\",\n", pad));
            code.push_str(&format!("{}    ];\n", pad));
            code.push_str(&format!("{}    agents.choose(&mut rand::thread_rng()).unwrap().to_string()\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::OcrCaptcha(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// OCR Captcha: requires rusty-tesseract and Tesseract 4+ installed\n", pad));
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let img = rusty_tesseract::Image::from_dynamic_image(&image::load_from_memory(&base64::engine::general_purpose::STANDARD.decode(&{}).unwrap()).unwrap()).unwrap();\n", pad, var_name(&s.input_var)));
            code.push_str(&format!("{}    let args = rusty_tesseract::Args {{ lang: \"{}\".to_string(), psm: Some({}), ..Default::default() }};\n", pad, escape_str(&s.language), s.psm));
            code.push_str(&format!("{}    rusty_tesseract::image_to_string(&img, &args).unwrap_or_default().trim().to_string()\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::RecaptchaInvisible(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// reCAPTCHA Invisible solver\n", pad));
            code.push_str(&format!("{}let anchor_resp = client.get(\"{}\")\n", pad, escape_str(&s.anchor_url)));
            code.push_str(&format!("{}    .header(\"User-Agent\", \"{}\")\n", pad, escape_str(&s.user_agent)));
            code.push_str(&format!("{}    .send().await?.text().await?;\n", pad));
            code.push_str(&format!("{}let token = anchor_resp.split(\"recaptcha-token\\\" value=\\\"\").nth(1)\n", pad));
            code.push_str(&format!("{}    .and_then(|s| s.split('\"').next()).unwrap_or_default().to_string();\n", pad));
            code.push_str(&format!("{}let reload_body = format!(\"v={}&reason=q&c={{}}&k={}&co={}&size={}\", token);\n",
                pad, escape_str(&s.v), escape_str(&s.sitekey), escape_str(&s.co), escape_str(&s.size)));
            code.push_str(&format!("{}let reload_resp = client.post(\"{}\")\n", pad, escape_str(&s.reload_url)));
            code.push_str(&format!("{}    .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n", pad));
            code.push_str(&format!("{}    .body(reload_body).send().await?.text().await?;\n", pad));
            code.push_str(&format!("{}{}{}= reload_resp.split(\"\\\"rresp\\\",\\\"\").nth(1)\n", pad, letkw, vn));
            code.push_str(&format!("{}    .and_then(|s| s.split('\"').next()).unwrap_or_default().to_string();\n", pad));
        }
        BlockSettings::XacfSensor(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// XACF Sensor Data generation\n", pad));
            code.push_str(&format!("{}{}{}= format!(\n", pad, letkw, vn));
            code.push_str(&format!("{}    \"{}|{}|iPhone14,3|18.1|{{}}|1170x2532||{{}}|0.0,-9.8,0.0|{{}}\",\n", pad, escape_str(&s.version), escape_str(&s.bundle_id)));
            code.push_str(&format!("{}    std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_millis(),\n", pad));
            code.push_str(&format!("{}    rand::Rng::gen_range(&mut rand::thread_rng(), 100..999),\n", pad));
            code.push_str(&format!("{}    rand::Rng::gen_range(&mut rand::thread_rng(), 10000..99999),\n", pad));
            code.push_str(&format!("{});\n", pad));
        }
        BlockSettings::RandomData(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// Random Data: {:?}\n", pad, s.data_type));
            match s.data_type {
                RandomDataType::String => {
                    code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
                    code.push_str(&format!("{}    let mut rng = rand::thread_rng();\n", pad));
                    code.push_str(&format!("{}    (0..{}).map(|_| rng.sample(rand::distributions::Alphanumeric) as char).collect::<String>()\n", pad, s.string_length));
                    code.push_str(&format!("{}}};\n", pad));
                }
                RandomDataType::Uuid => {
                    code.push_str(&format!("{}{}{}= uuid::Uuid::new_v4().to_string();\n", pad, letkw, vn));
                }
                RandomDataType::Number => {
                    code.push_str(&format!("{}{}{}= rand::Rng::gen_range(&mut rand::thread_rng(), {}..={}).to_string();\n", pad, letkw, vn, s.number_min, s.number_max));
                }
                RandomDataType::Email => {
                    code.push_str(&format!("{}{}{}= format!(\"{{}}@gmail.com\", uuid::Uuid::new_v4().to_string().split('-').next().unwrap());\n", pad, letkw, vn));
                }
                _ => {
                    code.push_str(&format!("{}{}{}= String::from(\"TODO: random {:?}\");\n", pad, letkw, vn, s.data_type));
                }
            }
        }
        BlockSettings::DataDomeSensor(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// DataDome sensor data generation\n", pad));
            code.push_str(&format!("{}// Credit: glizzykingdreko/datadome-wasm\n", pad));
            code.push_str(&format!("{}{}{}= String::from(\"TODO: DataDome sensor generation for {}\");\n", pad, letkw, vn, escape_str(&s.site_url)));
        }
        BlockSettings::Plugin(s) => {
            code.push_str(&format!("{}// Plugin block: {} (requires DLL plugin at runtime)\n", pad, s.plugin_block_type));
            if !s.output_var.is_empty() {
                let letkw = vars.let_or_assign(&s.output_var);
                let vn = var_name(&s.output_var);
                code.push_str(&format!("{}{}{}= String::new(); // Plugin output\n", pad, letkw, vn));
            }
        }
        BlockSettings::Group(s) => {
            code.push_str(&format!("{}// Group: {}\n", pad, block.label));
            for child in &s.blocks {
                if !child.disabled {
                    code.push_str(&generate_block_code(child, indent, vars));
                }
            }
        }
        BlockSettings::TcpRequest(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let mut stream = tokio::net::TcpStream::connect(\"{}:{}\").await?;\n", pad, escape_str(&s.host), s.port));
            if !s.data.is_empty() {
                code.push_str(&format!("{}    stream.write_all(b\"{}\").await?;\n", pad, escape_str(&s.data)));
                code.push_str(&format!("{}    stream.flush().await?;\n", pad));
            }
            code.push_str(&format!("{}    let mut buf = vec![0u8; 65536];\n", pad));
            code.push_str(&format!("{}    let n = stream.read(&mut buf).await.unwrap_or(0);\n", pad));
            code.push_str(&format!("{}    String::from_utf8_lossy(&buf[..n]).to_string()\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::UdpRequest(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let socket = tokio::net::UdpSocket::bind(\"0.0.0.0:0\").await?;\n", pad));
            code.push_str(&format!("{}    socket.send_to(b\"{}\", \"{}:{}\").await?;\n", pad, escape_str(&s.data), escape_str(&s.host), s.port));
            code.push_str(&format!("{}    let mut buf = vec![0u8; 65536];\n", pad));
            code.push_str(&format!("{}    let (n, _) = socket.recv_from(&mut buf).await?;\n", pad));
            code.push_str(&format!("{}    String::from_utf8_lossy(&buf[..n]).to_string()\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::FtpRequest(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let stream = tokio::net::TcpStream::connect(\"{}:{}\").await?;\n", pad, escape_str(&s.host), s.port));
            code.push_str(&format!("{}    let (r, mut w) = tokio::io::split(stream);\n", pad));
            code.push_str(&format!("{}    let mut r = tokio::io::BufReader::new(r);\n", pad));
            code.push_str(&format!("{}    let mut transcript = String::new();\n", pad));
            code.push_str(&format!("{}    let mut line = String::new();\n", pad));
            code.push_str(&format!("{}    r.read_line(&mut line).await?; // banner\n", pad));
            code.push_str(&format!("{}    transcript.push_str(&line);\n", pad));
            code.push_str(&format!("{}    for cmd in [\"USER {}\", \"PASS {}\", \"{}\", \"QUIT\"] {{\n",
                pad, escape_str(&s.username), escape_str(&s.password), escape_str(&s.command)));
            code.push_str(&format!("{}        w.write_all(format!(\"{{}}\\r\\n\", cmd).as_bytes()).await?;\n", pad));
            code.push_str(&format!("{}        w.flush().await?;\n", pad));
            code.push_str(&format!("{}        line.clear();\n", pad));
            code.push_str(&format!("{}        r.read_line(&mut line).await?;\n", pad));
            code.push_str(&format!("{}        transcript.push_str(&line);\n", pad));
            code.push_str(&format!("{}    }}\n", pad));
            code.push_str(&format!("{}    transcript\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::SshRequest(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let mut stream = tokio::net::TcpStream::connect(\"{}:{}\").await?;\n", pad, escape_str(&s.host), s.port));
            code.push_str(&format!("{}    let mut buf = vec![0u8; 4096];\n", pad));
            code.push_str(&format!("{}    let n = stream.read(&mut buf).await?;\n", pad));
            code.push_str(&format!("{}    let banner = String::from_utf8_lossy(&buf[..n]).to_string();\n", pad));
            code.push_str(&format!("{}    stream.write_all(b\"SSH-2.0-ReqFlow_1.0\\r\\n\").await?;\n", pad));
            code.push_str(&format!("{}    banner // Note: full SSH auth requires ssh2 crate\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::ImapRequest(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// IMAP connection to {}:{}\n", pad, escape_str(&s.host), s.port));
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let stream = tokio::net::TcpStream::connect(\"{}:{}\").await?;\n", pad, escape_str(&s.host), s.port));
            if s.use_tls {
                code.push_str(&format!("{}    let connector = native_tls::TlsConnector::new()?;\n", pad));
                code.push_str(&format!("{}    let connector = tokio_native_tls::TlsConnector::from(connector);\n", pad));
                code.push_str(&format!("{}    let stream = connector.connect(\"{}\", stream).await?;\n", pad, escape_str(&s.host)));
            }
            code.push_str(&format!("{}    let (r, mut w) = tokio::io::split(stream);\n", pad));
            code.push_str(&format!("{}    let mut r = tokio::io::BufReader::new(r);\n", pad));
            code.push_str(&format!("{}    let mut line = String::new(); let mut transcript = String::new();\n", pad));
            code.push_str(&format!("{}    r.read_line(&mut line).await?; transcript.push_str(&line); // banner\n", pad));
            code.push_str(&format!("{}    w.write_all(b\"a001 LOGIN {} {}\\r\\n\").await?; w.flush().await?;\n",
                pad, escape_str(&s.username), escape_str(&s.password)));
            code.push_str(&format!("{}    line.clear(); r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
            if !s.command.is_empty() && s.command != "LOGIN" {
                code.push_str(&format!("{}    w.write_all(b\"a002 {}\\r\\n\").await?; w.flush().await?;\n", pad, escape_str(&s.command)));
                code.push_str(&format!("{}    line.clear(); r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
            }
            code.push_str(&format!("{}    w.write_all(b\"a003 LOGOUT\\r\\n\").await?;\n", pad));
            code.push_str(&format!("{}    transcript\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::SmtpRequest(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// SMTP connection to {}:{}\n", pad, escape_str(&s.host), s.port));
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let stream = tokio::net::TcpStream::connect(\"{}:{}\").await?;\n", pad, escape_str(&s.host), s.port));
            if s.use_tls {
                code.push_str(&format!("{}    let connector = native_tls::TlsConnector::new()?;\n", pad));
                code.push_str(&format!("{}    let connector = tokio_native_tls::TlsConnector::from(connector);\n", pad));
                code.push_str(&format!("{}    let stream = connector.connect(\"{}\", stream).await?;\n", pad, escape_str(&s.host)));
            }
            code.push_str(&format!("{}    let (r, mut w) = tokio::io::split(stream);\n", pad));
            code.push_str(&format!("{}    let mut r = tokio::io::BufReader::new(r);\n", pad));
            code.push_str(&format!("{}    let mut line = String::new(); let mut transcript = String::new();\n", pad));
            code.push_str(&format!("{}    r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
            code.push_str(&format!("{}    w.write_all(b\"EHLO reqflow\\r\\n\").await?; w.flush().await?;\n", pad));
            code.push_str(&format!("{}    line.clear(); r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
            if !s.username.is_empty() {
                code.push_str(&format!("{}    w.write_all(b\"AUTH LOGIN\\r\\n\").await?; w.flush().await?;\n", pad));
                code.push_str(&format!("{}    line.clear(); r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
                code.push_str(&format!("{}    w.write_all(format!(\"{{}}\\r\\n\", base64::engine::general_purpose::STANDARD.encode(\"{}\")).as_bytes()).await?;\n", pad, escape_str(&s.username)));
                code.push_str(&format!("{}    w.flush().await?; line.clear(); r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
                code.push_str(&format!("{}    w.write_all(format!(\"{{}}\\r\\n\", base64::engine::general_purpose::STANDARD.encode(\"{}\")).as_bytes()).await?;\n", pad, escape_str(&s.password)));
                code.push_str(&format!("{}    w.flush().await?; line.clear(); r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
            }
            code.push_str(&format!("{}    w.write_all(b\"QUIT\\r\\n\").await?;\n", pad));
            code.push_str(&format!("{}    transcript\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::PopRequest(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// POP3 connection to {}:{}\n", pad, escape_str(&s.host), s.port));
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let stream = tokio::net::TcpStream::connect(\"{}:{}\").await?;\n", pad, escape_str(&s.host), s.port));
            if s.use_tls {
                code.push_str(&format!("{}    let connector = native_tls::TlsConnector::new()?;\n", pad));
                code.push_str(&format!("{}    let connector = tokio_native_tls::TlsConnector::from(connector);\n", pad));
                code.push_str(&format!("{}    let stream = connector.connect(\"{}\", stream).await?;\n", pad, escape_str(&s.host)));
            }
            code.push_str(&format!("{}    let (r, mut w) = tokio::io::split(stream);\n", pad));
            code.push_str(&format!("{}    let mut r = tokio::io::BufReader::new(r);\n", pad));
            code.push_str(&format!("{}    let mut line = String::new(); let mut transcript = String::new();\n", pad));
            code.push_str(&format!("{}    r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
            code.push_str(&format!("{}    w.write_all(b\"USER {}\\r\\n\").await?; w.flush().await?;\n", pad, escape_str(&s.username)));
            code.push_str(&format!("{}    line.clear(); r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
            code.push_str(&format!("{}    w.write_all(b\"PASS {}\\r\\n\").await?; w.flush().await?;\n", pad, escape_str(&s.password)));
            code.push_str(&format!("{}    line.clear(); r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
            if !s.command.is_empty() {
                code.push_str(&format!("{}    w.write_all(b\"{}\\r\\n\").await?; w.flush().await?;\n", pad, escape_str(&s.command)));
                code.push_str(&format!("{}    line.clear(); r.read_line(&mut line).await?; transcript.push_str(&line);\n", pad));
            }
            code.push_str(&format!("{}    w.write_all(b\"QUIT\\r\\n\").await?;\n", pad));
            code.push_str(&format!("{}    transcript\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::WebSocket(_s) => {
            code.push_str(&format!("{}// WebSocket: requires tokio-tungstenite crate\n", pad));
            code.push_str(&format!("{}// TODO: implement WebSocket connection\n", pad));
        }
        BlockSettings::CaptchaSolver(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// Captcha solver via {} API\n", pad, escape_str(&s.solver_service)));
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let create_resp = client.post(\"https://api.capsolver.com/createTask\")\n", pad));
            code.push_str(&format!("{}        .header(\"Content-Type\", \"application/json\")\n", pad));
            code.push_str(&format!("{}        .body(serde_json::json!({{\"clientKey\": \"{}\", \"task\": {{\"type\": \"RecaptchaV2TaskProxyless\", \"websiteURL\": \"{}\", \"websiteKey\": \"{}\"}}}}).to_string())\n",
                pad, escape_str(&s.api_key), escape_str(&s.page_url), escape_str(&s.site_key)));
            code.push_str(&format!("{}        .send().await?.text().await?;\n", pad));
            code.push_str(&format!("{}    let task_id = serde_json::from_str::<Value>(&create_resp)?[\"taskId\"].as_str().unwrap_or_default().to_string();\n", pad));
            code.push_str(&format!("{}    loop {{\n", pad));
            code.push_str(&format!("{}        tokio::time::sleep(std::time::Duration::from_secs(5)).await;\n", pad));
            code.push_str(&format!("{}        let poll = client.post(\"https://api.capsolver.com/getTaskResult\")\n", pad));
            code.push_str(&format!("{}            .header(\"Content-Type\", \"application/json\")\n", pad));
            code.push_str(&format!("{}            .body(serde_json::json!({{\"clientKey\": \"{}\", \"taskId\": task_id}}).to_string())\n", pad, escape_str(&s.api_key)));
            code.push_str(&format!("{}            .send().await?.text().await?;\n", pad));
            code.push_str(&format!("{}        let json: Value = serde_json::from_str(&poll)?;\n", pad));
            code.push_str(&format!("{}        if json[\"status\"] == \"ready\" {{ break json[\"solution\"][\"gRecaptchaResponse\"].as_str().unwrap_or_default().to_string(); }}\n", pad));
            code.push_str(&format!("{}    }}\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::CloudflareBypass(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// Cloudflare bypass via FlareSolverr\n", pad));
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let resp = client.post(\"{}\")\n", pad, escape_str(&s.flaresolverr_url)));
            code.push_str(&format!("{}        .header(\"Content-Type\", \"application/json\")\n", pad));
            code.push_str(&format!("{}        .body(serde_json::json!({{\"cmd\": \"request.get\", \"url\": \"{}\"}}).to_string())\n", pad, escape_str(&s.url)));
            code.push_str(&format!("{}        .send().await?.text().await?;\n", pad));
            code.push_str(&format!("{}    let json: Value = serde_json::from_str(&resp)?;\n", pad));
            code.push_str(&format!("{}    json[\"solution\"][\"cookies\"].as_array()\n", pad));
            code.push_str(&format!("{}        .map(|a| a.iter().filter_map(|c| Some(format!(\"{{}}={{}}\", c[\"name\"].as_str()?, c[\"value\"].as_str()?))).collect::<Vec<_>>().join(\"; \"))\n", pad));
            code.push_str(&format!("{}        .unwrap_or_default()\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
        BlockSettings::LaravelCsrf(s) => {
            let letkw = vars.let_or_assign(&s.output_var);
            let vn = var_name(&s.output_var);
            code.push_str(&format!("{}// Laravel CSRF token extraction\n", pad));
            code.push_str(&format!("{}let csrf_page = client.get(\"{}\")\n", pad, escape_str(&s.url)));
            code.push_str(&format!("{}    .send().await?.text().await?;\n", pad));
            code.push_str(&format!("{}{}{}= {{\n", pad, letkw, vn));
            code.push_str(&format!("{}    let doc = Html::parse_document(&csrf_page);\n", pad));
            code.push_str(&format!("{}    let sel = Selector::parse(\"{}\").unwrap();\n", pad, escape_str(&s.csrf_selector)));
            code.push_str(&format!("{}    doc.select(&sel).next().and_then(|el| el.value().attr(\"value\")).unwrap_or_default().to_string()\n", pad));
            code.push_str(&format!("{}}};\n", pad));
        }
    }

    code
}

fn generate_condition_code(cond: &KeyCondition) -> String {
    let source = if cond.source == "data.RESPONSECODE" {
        "status_code".to_string()
    } else {
        var_name(&cond.source)
    };

    match cond.comparison {
        Comparison::Contains => format!("source.contains(\"{}\")", escape_str(&cond.value)),
        Comparison::NotContains => format!("!source.contains(\"{}\")", escape_str(&cond.value)),
        Comparison::EqualTo => {
            if cond.source == "data.RESPONSECODE" {
                format!("{} == {}", source, cond.value)
            } else {
                format!("{} == \"{}\"", source, escape_str(&cond.value))
            }
        }
        Comparison::NotEqualTo => format!("{} != \"{}\"", source, escape_str(&cond.value)),
        Comparison::GreaterThan => format!("{} > {}", source, cond.value),
        Comparison::LessThan => format!("{} < {}", source, cond.value),
        Comparison::MatchesRegex => format!("Regex::new(r\"{}\").unwrap().is_match(&{})", escape_str(&cond.value), source),
        Comparison::Exists => format!("!{}.is_empty()", source),
        Comparison::NotExists => format!("{}.is_empty()", source),
    }
}

fn var_name(s: &str) -> String {
    s.replace('.', "_")
        .replace('@', "")
        .to_lowercase()
}

fn escape_str(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
}
