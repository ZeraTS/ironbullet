mod block_codegen;
mod helpers;

use crate::pipeline::block::*;
use crate::pipeline::Pipeline;
use helpers::VarTracker;
use block_codegen::generate_block_code;

/// Generate a standalone Rust program from a pipeline
pub fn generate_rust_code(pipeline: &Pipeline) -> String {
    let mut code = String::new();

    // Scan blocks to determine which imports are needed
    let mut needed = ImportFlags::default();
    scan_blocks_for_imports(&pipeline.blocks, &mut needed);

    code.push_str("// Generated by ironbullet\n");
    code.push_str("use wreq::Client;\n");
    code.push_str("use wreq_util::Emulation;\n");
    if needed.regex {
        code.push_str("use regex::Regex;\n");
    }
    if needed.serde_json {
        code.push_str("use serde_json::Value;\n");
    }
    if needed.scraper {
        code.push_str("use scraper::{Html, Selector};\n");
    }
    if needed.xpath {
        code.push_str("use sxd_document;\nuse sxd_xpath;\n");
    }
    if needed.crypto {
        code.push_str("use sha2::Digest;\n");
    }
    if needed.chrono {
        code.push_str("use chrono::prelude::*;\n");
    }
    if needed.browser {
        code.push_str("use chromiumoxide::browser::{Browser, BrowserConfig};\n");
        code.push_str("use futures::StreamExt;\n");
    }
    if needed.rand {
        code.push_str("use rand::Rng;\n");
    }
    if needed.net {
        code.push_str("use tokio::io::{AsyncReadExt, AsyncWriteExt, AsyncBufReadExt};\n");
    }
    if needed.urlencoding {
        code.push_str("// url encoding: use urlencoding::{encode, decode};\n");
    }
    if needed.base64 {
        code.push_str("use base64::Engine as _;\n");
    }
    if needed.uuid {
        code.push_str("use uuid::Uuid;\n");
    }
    code.push_str("\n");
    code.push_str("#[tokio::main]\n");
    code.push_str("async fn main() -> Result<(), Box<dyn std::error::Error>> {\n");

    // Client setup
    let browser = &pipeline.browser_settings.browser;
    let emulation = match browser.as_str() {
        "chrome" => "Chrome131",
        "firefox" => "Firefox133",
        "safari" => "Safari18",
        "edge" => "Edge131",
        _ => "Chrome131",
    };
    code.push_str(&format!("    let emulation = Emulation::{};\n", emulation));
    code.push_str("    let mut client = Client::builder()\n");
    code.push_str("        .emulation(emulation)\n");
    code.push_str("        .cookie_store(true)\n");
    code.push_str("        .build()?;\n\n");

    // Track defined variables
    let mut vars = VarTracker::new();

    // Generate blocks
    for (i, block) in pipeline.blocks.iter().enumerate() {
        if block.disabled {
            continue;
        }
        code.push_str(&format!("    // Block {}: {}\n", i + 1, block.label));
        code.push_str(&generate_block_code(block, 1, &mut vars));
        code.push_str("\n");
    }

    code.push_str("    Ok(())\n");
    code.push_str("}\n");

    code
}

// ── Import scanning ──

#[derive(Default)]
struct ImportFlags {
    regex: bool,
    serde_json: bool,
    scraper: bool,
    xpath: bool,
    crypto: bool,
    chrono: bool,
    browser: bool,
    urlencoding: bool,
    base64: bool,
    rand: bool,
    net: bool,
    uuid: bool,
}

fn scan_blocks_for_imports(blocks: &[Block], flags: &mut ImportFlags) {
    for block in blocks {
        match &block.settings {
            BlockSettings::ParseRegex(_) => flags.regex = true,
            BlockSettings::ParseJSON(_) => flags.serde_json = true,
            BlockSettings::ParseCSS(_) => flags.scraper = true,
            BlockSettings::ParseXPath(_) => flags.xpath = true,
            BlockSettings::CryptoFunction(_) => flags.crypto = true,
            BlockSettings::DateFunction(_) => flags.chrono = true,
            BlockSettings::BrowserOpen(_) | BlockSettings::NavigateTo(_) |
            BlockSettings::ClickElement(_) | BlockSettings::TypeText(_) |
            BlockSettings::WaitForElement(_) | BlockSettings::GetElementText(_) |
            BlockSettings::Screenshot(_) | BlockSettings::ExecuteJs(_) => flags.browser = true,
            BlockSettings::StringFunction(s) => {
                match s.function_type {
                    StringFnType::URLEncode | StringFnType::URLDecode => flags.urlencoding = true,
                    StringFnType::Base64Encode | StringFnType::Base64Decode => flags.base64 = true,
                    _ => {}
                }
            }
            BlockSettings::ConversionFunction(s) => {
                if s.from_type == "base64" || s.to_type == "base64" {
                    flags.base64 = true;
                }
            }
            BlockSettings::RandomData(_) => { flags.rand = true; }
            BlockSettings::TcpRequest(_) | BlockSettings::UdpRequest(_) |
            BlockSettings::FtpRequest(_) | BlockSettings::SshRequest(_) |
            BlockSettings::ImapRequest(_) | BlockSettings::SmtpRequest(_) |
            BlockSettings::PopRequest(_) => { flags.net = true; }
            BlockSettings::CaptchaSolver(_) | BlockSettings::CloudflareBypass(_) => { flags.serde_json = true; }
            BlockSettings::LaravelCsrf(_) => { flags.scraper = true; }
            BlockSettings::Script(s) => {
                if s.code.contains("SVB UnixTimeToDate:") {
                    flags.chrono = true;
                }
                if s.code.contains("OB2 C# preamble") {
                    if s.code.contains("MatchRegexGroups") {
                        flags.regex = true;
                    }
                    if s.code.contains("Guid.NewGuid()") {
                        flags.uuid = true;
                    }
                }
            }
            BlockSettings::IfElse(s) => {
                scan_blocks_for_imports(&s.true_blocks, flags);
                scan_blocks_for_imports(&s.false_blocks, flags);
            }
            BlockSettings::Loop(s) => {
                scan_blocks_for_imports(&s.blocks, flags);
            }
            BlockSettings::Group(s) => {
                scan_blocks_for_imports(&s.blocks, flags);
            }
            _ => {}
        }
    }
}
